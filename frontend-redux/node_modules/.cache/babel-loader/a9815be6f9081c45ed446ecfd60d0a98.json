{"ast":null,"code":"import uniq from 'lodash/uniq';\nimport uniqBy from 'lodash/uniqBy';\nimport sortBy from 'lodash/sortBy';\nimport last from 'lodash/last';\nimport isDate from 'lodash/isDate';\nimport { utcParse, timeParse } from 'd3-time-format';\nimport { scaleLinear, scalePoint, scaleBand, scaleUtc, scaleTime, scaleLog, scaleSymlog } from 'd3-scale';\nimport { timeInterval, timeMillisecond, utcMillisecond, timeSecond, utcSecond, timeMinute, utcMinute, timeHour, utcHour, timeWeek, utcWeek, timeSunday, utcSunday, timeMonday, utcMonday, timeTuesday, utcTuesday, timeWednesday, utcWednesday, timeThursday, utcThursday, timeFriday, utcFriday, timeSaturday, utcSaturday, timeMonth, utcMonth, timeYear, utcYear } from 'd3-time';\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar timePrecisions = ['millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year'];\nvar precisionCutOffs = [function (date) {\n  return date.setMilliseconds(0);\n}, function (date) {\n  return date.setSeconds(0);\n}, function (date) {\n  return date.setMinutes(0);\n}, function (date) {\n  return date.setHours(0);\n}, function (date) {\n  return date.setDate(1);\n}, function (date) {\n  return date.setMonth(0);\n}];\nvar precisionCutOffsByType = {\n  millisecond: [],\n  second: precisionCutOffs.slice(0, 1),\n  minute: precisionCutOffs.slice(0, 2),\n  hour: precisionCutOffs.slice(0, 3),\n  day: precisionCutOffs.slice(0, 4),\n  month: precisionCutOffs.slice(0, 5),\n  year: precisionCutOffs.slice(0, 6)\n};\n\nvar createPrecisionMethod = function createPrecisionMethod(precision) {\n  return function (date) {\n    precisionCutOffsByType[precision].forEach(function (cutOff) {\n      cutOff(date);\n    });\n    return date;\n  };\n};\n\nvar createDateNormalizer = function createDateNormalizer(_ref) {\n  var _ref$format = _ref.format,\n      format = _ref$format === void 0 ? 'native' : _ref$format,\n      _ref$precision = _ref.precision,\n      precision = _ref$precision === void 0 ? 'millisecond' : _ref$precision,\n      _ref$useUTC = _ref.useUTC,\n      useUTC = _ref$useUTC === void 0 ? true : _ref$useUTC;\n  var precisionFn = createPrecisionMethod(precision);\n  return function (value) {\n    if (value === undefined) {\n      return value;\n    }\n\n    if (format === 'native' || value instanceof Date) {\n      return precisionFn(value);\n    }\n\n    var parseTime = useUTC ? utcParse(format) : timeParse(format);\n    return precisionFn(parseTime(value));\n  };\n};\n\nvar createLinearScale = function createLinearScale(_ref, data, size, axis) {\n  var _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 0 : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === void 0 ? false : _ref$reverse,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === void 0 ? false : _ref$clamp,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === void 0 ? false : _ref$nice;\n  var minValue;\n\n  if (min === 'auto') {\n    var _data$minStacked;\n\n    minValue = stacked === true ? (_data$minStacked = data.minStacked) !== null && _data$minStacked !== void 0 ? _data$minStacked : 0 : data.min;\n  } else {\n    minValue = min;\n  }\n\n  var maxValue;\n\n  if (max === 'auto') {\n    var _data$maxStacked;\n\n    maxValue = stacked === true ? (_data$maxStacked = data.maxStacked) !== null && _data$maxStacked !== void 0 ? _data$maxStacked : 0 : data.max;\n  } else {\n    maxValue = max;\n  }\n\n  var scale = scaleLinear().rangeRound(axis === 'x' ? [0, size] : [size, 0]).domain(reverse ? [maxValue, minValue] : [minValue, maxValue]).clamp(clamp);\n  if (nice === true) scale.nice();else if (typeof nice === 'number') scale.nice(nice);\n  return castLinearScale(scale, stacked);\n};\n\nvar castLinearScale = function castLinearScale(scale) {\n  var stacked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var typedScale = scale;\n  typedScale.type = 'linear';\n  typedScale.stacked = stacked;\n  return typedScale;\n};\n\nvar createPointScale = function createPointScale(_spec, data, size) {\n  var scale = scalePoint().range([0, size]).domain(data.all);\n  var typedScale = scale;\n  typedScale.type = 'point';\n  return typedScale;\n};\n\nvar createBandScale = function createBandScale(_ref, data, size, axis) {\n  var _ref$round = _ref.round,\n      round = _ref$round === void 0 ? true : _ref$round;\n  var scale = scaleBand().range(axis === 'x' ? [0, size] : [size, 0]).domain(data.all).round(round);\n  return castBandScale(scale);\n};\n\nvar castBandScale = function castBandScale(scale) {\n  var typedScale = scale;\n  typedScale.type = 'band';\n  return typedScale;\n};\n\nvar createTimeScale = function createTimeScale(_ref, data, size) {\n  var _ref$format = _ref.format,\n      format = _ref$format === void 0 ? 'native' : _ref$format,\n      _ref$precision = _ref.precision,\n      precision = _ref$precision === void 0 ? 'millisecond' : _ref$precision,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 'auto' : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max,\n      _ref$useUTC = _ref.useUTC,\n      useUTC = _ref$useUTC === void 0 ? true : _ref$useUTC,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === void 0 ? false : _ref$nice;\n  var normalize = createDateNormalizer({\n    format: format,\n    precision: precision,\n    useUTC: useUTC\n  });\n  var minValue;\n\n  if (min === 'auto') {\n    minValue = normalize(data.min);\n  } else if (format !== 'native') {\n    minValue = normalize(min);\n  } else {\n    minValue = min;\n  }\n\n  var maxValue;\n\n  if (max === 'auto') {\n    maxValue = normalize(data.max);\n  } else if (format !== 'native') {\n    maxValue = normalize(max);\n  } else {\n    maxValue = max;\n  }\n\n  var scale = useUTC ? scaleUtc() : scaleTime();\n  scale.range([0, size]);\n  if (minValue && maxValue) scale.domain([minValue, maxValue]);\n  if (nice === true) scale.nice();else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice);\n  var typedScale = scale;\n  typedScale.type = 'time';\n  typedScale.useUTC = useUTC;\n  return typedScale;\n};\n\nvar createLogScale = function createLogScale(_ref, data, size, axis) {\n  var _ref$base = _ref.base,\n      base = _ref$base === void 0 ? 10 : _ref$base,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 'auto' : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max;\n  var hasZero = data.all.some(function (v) {\n    return v === 0;\n  });\n\n  if (hasZero) {\n    throw new Error(\"a log scale domain must not include or cross zero\");\n  }\n\n  var sign;\n  var hasMixedSign = false;\n  data.all.filter(function (v) {\n    return v != null;\n  }).forEach(function (v) {\n    if (hasMixedSign) return;\n\n    if (sign === undefined) {\n      sign = Math.sign(v);\n    } else if (Math.sign(v) !== sign) {\n      hasMixedSign = true;\n    }\n  });\n\n  if (hasMixedSign) {\n    throw new Error(\"a log scale domain must be strictly-positive or strictly-negative\");\n  }\n\n  var minValue;\n\n  if (min === 'auto') {\n    minValue = data.min;\n  } else {\n    minValue = min;\n  }\n\n  var maxValue;\n\n  if (max === 'auto') {\n    maxValue = data.max;\n  } else {\n    maxValue = max;\n  }\n\n  var scale = scaleLog().domain([minValue, maxValue]).rangeRound(axis === 'x' ? [0, size] : [size, 0]).base(base).nice();\n  var typedScale = scale;\n  typedScale.type = 'log';\n  return scale;\n};\n\nvar createSymlogScale = function createSymlogScale(_ref, data, size, axis) {\n  var _ref$constant = _ref.constant,\n      constant = _ref$constant === void 0 ? 1 : _ref$constant,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 'auto' : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === void 0 ? false : _ref$reverse;\n  var minValue;\n\n  if (min === 'auto') {\n    minValue = data.min;\n  } else {\n    minValue = min;\n  }\n\n  var maxValue;\n\n  if (max === 'auto') {\n    maxValue = data.max;\n  } else {\n    maxValue = max;\n  }\n\n  var scale = scaleSymlog().constant(constant).rangeRound(axis === 'x' ? [0, size] : [size, 0]).nice();\n  if (reverse === true) scale.domain([maxValue, minValue]);else scale.domain([minValue, maxValue]);\n  var typedScale = scale;\n  typedScale.type = 'symlog';\n  return typedScale;\n};\n\nvar getOtherAxis = function getOtherAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n};\n\nvar compareValues = function compareValues(a, b) {\n  return a === b;\n};\n\nvar compareDateValues = function compareDateValues(a, b) {\n  return a.getTime() === b.getTime();\n};\n\nfunction computeScale(spec, data, size, axis) {\n  switch (spec.type) {\n    case 'linear':\n      return createLinearScale(spec, data, size, axis);\n\n    case 'point':\n      return createPointScale(spec, data, size);\n\n    case 'band':\n      return createBandScale(spec, data, size, axis);\n\n    case 'time':\n      return createTimeScale(spec, data, size);\n\n    case 'log':\n      return createLogScale(spec, data, size, axis);\n\n    case 'symlog':\n      return createSymlogScale(spec, data, size, axis);\n\n    default:\n      throw new Error('invalid scale spec');\n  }\n}\n\nvar nestSerieData = function nestSerieData(serie) {\n  return _objectSpread2(_objectSpread2({}, serie), {}, {\n    data: serie.data.map(function (d) {\n      return {\n        data: _objectSpread2({}, d)\n      };\n    })\n  });\n};\n\nvar getDatumAxisPosition = function getDatumAxisPosition(datum, axis, scale) {\n  var _scale;\n\n  if ('stacked' in scale && scale.stacked) {\n    var stackedValue = datum.data[axis === 'x' ? 'xStacked' : 'yStacked'];\n\n    if (stackedValue === null || stackedValue === undefined) {\n      return null;\n    }\n\n    return scale(stackedValue);\n  }\n\n  return (_scale = scale(datum.data[axis])) !== null && _scale !== void 0 ? _scale : null;\n};\n\nvar computeXYScalesForSeries = function computeXYScalesForSeries(series, xScaleSpec, yScaleSpec, width, height) {\n  var nestedSeries = series.map(function (serie) {\n    return nestSerieData(serie);\n  });\n  var xy = generateSeriesXY(nestedSeries, xScaleSpec, yScaleSpec);\n\n  if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n    stackX(xy, nestedSeries);\n  }\n\n  if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n    stackY(xy, nestedSeries);\n  }\n\n  var xScale = computeScale(xScaleSpec, xy.x, width, 'x');\n  var yScale = computeScale(yScaleSpec, xy.y, height, 'y');\n  var computedSeries = nestedSeries.map(function (serie) {\n    return _objectSpread2(_objectSpread2({}, serie), {}, {\n      data: serie.data.map(function (datum) {\n        return _objectSpread2(_objectSpread2({}, datum), {}, {\n          position: {\n            x: getDatumAxisPosition(datum, 'x', xScale),\n            y: getDatumAxisPosition(datum, 'y', yScale)\n          }\n        });\n      })\n    });\n  });\n  return _objectSpread2(_objectSpread2({}, xy), {}, {\n    series: computedSeries,\n    xScale: xScale,\n    yScale: yScale\n  });\n};\n\nvar generateSeriesXY = function generateSeriesXY(series, xScaleSpec, yScaleSpec) {\n  return {\n    x: generateSeriesAxis(series, 'x', xScaleSpec),\n    y: generateSeriesAxis(series, 'y', yScaleSpec)\n  };\n};\n\nvar generateSeriesAxis = function generateSeriesAxis(series, axis, scaleSpec) {\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      _ref$getValue = _ref.getValue,\n      getValue = _ref$getValue === void 0 ? function (d) {\n    return d.data[axis];\n  } : _ref$getValue,\n      _ref$setValue = _ref.setValue,\n      setValue = _ref$setValue === void 0 ? function (d, v) {\n    d.data[axis] = v;\n  } : _ref$setValue;\n\n  if (scaleSpec.type === 'linear') {\n    series.forEach(function (serie) {\n      serie.data.forEach(function (d) {\n        var value = getValue(d);\n\n        if (value) {\n          setValue(d, parseFloat(String(value)));\n        }\n      });\n    });\n  } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n    var parseTime = createDateNormalizer(scaleSpec);\n    series.forEach(function (serie) {\n      serie.data.forEach(function (d) {\n        var value = getValue(d);\n\n        if (value) {\n          setValue(d, parseTime(value));\n        }\n      });\n    });\n  }\n\n  var values = [];\n  series.forEach(function (serie) {\n    serie.data.forEach(function (d) {\n      values.push(getValue(d));\n    });\n  });\n\n  switch (scaleSpec.type) {\n    case 'linear':\n      {\n        var all = sortBy(uniq(values).filter(function (v) {\n          return v !== null;\n        }), function (v) {\n          return v;\n        });\n        return {\n          all: all,\n          min: Math.min.apply(Math, _toConsumableArray(all)),\n          max: Math.max.apply(Math, _toConsumableArray(all))\n        };\n      }\n\n    case 'time':\n      {\n        var _all = uniqBy(values, function (v) {\n          return v.getTime();\n        }).slice(0).sort(function (a, b) {\n          return b.getTime() - a.getTime();\n        }).reverse();\n\n        return {\n          all: _all,\n          min: _all[0],\n          max: last(_all)\n        };\n      }\n\n    default:\n      {\n        var _all2 = uniq(values);\n\n        return {\n          all: _all2,\n          min: _all2[0],\n          max: last(_all2)\n        };\n      }\n  }\n};\n\nvar stackAxis = function stackAxis(axis, xy, series) {\n  var otherAxis = getOtherAxis(axis);\n  var all = [];\n  xy[otherAxis].all.forEach(function (v) {\n    var compare = isDate(v) ? compareDateValues : compareValues;\n    var stack = [];\n    series.forEach(function (serie) {\n      var datum = serie.data.find(function (d) {\n        return compare(d.data[otherAxis], v);\n      });\n      var value = null;\n      var stackValue = null;\n\n      if (datum !== undefined) {\n        value = datum.data[axis];\n\n        if (value !== null) {\n          var head = last(stack);\n\n          if (head === undefined) {\n            stackValue = value;\n          } else if (head !== null) {\n            stackValue = head + value;\n          }\n        }\n\n        datum.data[axis === 'x' ? 'xStacked' : 'yStacked'] = stackValue;\n      }\n\n      stack.push(stackValue);\n\n      if (stackValue !== null) {\n        all.push(stackValue);\n      }\n    });\n  });\n  xy[axis].minStacked = Math.min.apply(Math, all);\n  xy[axis].maxStacked = Math.max.apply(Math, all);\n};\n\nvar stackX = function stackX(xy, series) {\n  return stackAxis('x', xy, series);\n};\n\nvar stackY = function stackY(xy, series) {\n  return stackAxis('y', xy, series);\n};\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nvar centerScale = function centerScale(scale) {\n  var bandwidth = scale.bandwidth();\n  if (bandwidth === 0) return scale;\n  var offset = bandwidth / 2;\n\n  if (scale.round()) {\n    offset = Math.round(offset);\n  }\n\n  return function (d) {\n    var _scale;\n\n    return ((_scale = scale(d)) !== null && _scale !== void 0 ? _scale : 0) + offset;\n  };\n};\n\nvar timeDay = timeInterval(function (date) {\n  return date.setHours(0, 0, 0, 0);\n}, function (date, step) {\n  return date.setDate(date.getDate() + step);\n}, function (start, end) {\n  return (end.getTime() - start.getTime()) / 864e5;\n}, function (date) {\n  return Math.floor(date.getTime() / 864e5);\n});\nvar utcDay = timeInterval(function (date) {\n  return date.setUTCHours(0, 0, 0, 0);\n}, function (date, step) {\n  return date.setUTCDate(date.getUTCDate() + step);\n}, function (start, end) {\n  return (end.getTime() - start.getTime()) / 864e5;\n}, function (date) {\n  return Math.floor(date.getTime() / 864e5);\n});\nvar timeByType = {\n  millisecond: [timeMillisecond, utcMillisecond],\n  second: [timeSecond, utcSecond],\n  minute: [timeMinute, utcMinute],\n  hour: [timeHour, utcHour],\n  day: [timeDay, utcDay],\n  week: [timeWeek, utcWeek],\n  sunday: [timeSunday, utcSunday],\n  monday: [timeMonday, utcMonday],\n  tuesday: [timeTuesday, utcTuesday],\n  wednesday: [timeWednesday, utcWednesday],\n  thursday: [timeThursday, utcThursday],\n  friday: [timeFriday, utcFriday],\n  saturday: [timeSaturday, utcSaturday],\n  month: [timeMonth, utcMonth],\n  year: [timeYear, utcYear]\n};\nvar timeTypes = Object.keys(timeByType);\nvar timeIntervalRegexp = new RegExp(\"^every\\\\s*(\\\\d+)?\\\\s*(\".concat(timeTypes.join('|'), \")s?$\"), 'i');\n\nvar isInteger = function isInteger(value) {\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n};\n\nvar getScaleTicks = function getScaleTicks(scale, spec) {\n  if (Array.isArray(spec)) {\n    return spec;\n  }\n\n  if (typeof spec === 'string' && 'useUTC' in scale) {\n    var matches = spec.match(timeIntervalRegexp);\n\n    if (matches) {\n      var _matches = _slicedToArray(matches, 3),\n          amount = _matches[1],\n          type = _matches[2];\n\n      var timeType = timeByType[type][scale.useUTC ? 1 : 0];\n\n      if (type === 'day') {\n        var _timeType$every$range, _timeType$every;\n\n        var _scale$domain = scale.domain(),\n            _scale$domain2 = _slicedToArray(_scale$domain, 2),\n            start = _scale$domain2[0],\n            originalStop = _scale$domain2[1];\n\n        var stop = new Date(originalStop);\n        stop.setDate(stop.getDate() + 1);\n        return (_timeType$every$range = (_timeType$every = timeType.every(Number(amount !== null && amount !== void 0 ? amount : 1))) === null || _timeType$every === void 0 ? void 0 : _timeType$every.range(start, stop)) !== null && _timeType$every$range !== void 0 ? _timeType$every$range : [];\n      }\n\n      if (amount === undefined) {\n        return scale.ticks(timeType);\n      }\n\n      var interval = timeType.every(Number(amount));\n\n      if (interval) {\n        return scale.ticks(interval);\n      }\n    }\n\n    throw new Error(\"Invalid tickValues: \".concat(spec));\n  }\n\n  if ('ticks' in scale) {\n    if (spec === undefined) {\n      return scale.ticks();\n    }\n\n    if (isInteger(spec)) {\n      return scale.ticks(spec);\n    }\n  }\n\n  return scale.domain();\n};\n\nexport { castBandScale, castLinearScale, centerScale, compareDateValues, compareValues, computeScale, computeXYScalesForSeries, createBandScale, createDateNormalizer, createLinearScale, createLogScale, createPointScale, createPrecisionMethod, createSymlogScale, createTimeScale, generateSeriesAxis, generateSeriesXY, getOtherAxis, getScaleTicks, precisionCutOffs, precisionCutOffsByType, stackAxis, timePrecisions };","map":{"version":3,"sources":["../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../src/timeHelpers.ts","../src/linearScale.ts","../src/pointScale.ts","../src/bandScale.ts","../src/timeScale.ts","../src/logScale.ts","../src/symlogScale.ts","../src/compute.ts","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../src/ticks.ts"],"names":["arrayLikeToArray","arrayWithoutHoles","iterableToArray","unsupportedIterableToArray","nonIterableSpread","defineProperty","timePrecisions","precisionCutOffs","date","precisionCutOffsByType","millisecond","second","minute","hour","day","month","year","createPrecisionMethod","cutOff","createDateNormalizer","format","precision","useUTC","precisionFn","value","parseTime","utcParse","timeParse","createLinearScale","min","max","stacked","reverse","clamp","nice","minValue","data","maxValue","scale","scaleLinear","axis","castLinearScale","typedScale","createPointScale","scalePoint","createBandScale","round","scaleBand","castBandScale","createTimeScale","normalize","scaleUtc","scaleTime","createLogScale","base","hasZero","v","hasMixedSign","sign","Math","scaleLog","createSymlogScale","constant","scaleSymlog","getOtherAxis","compareValues","a","compareDateValues","b","spec","nestSerieData","getDatumAxisPosition","stackedValue","datum","computeXYScalesForSeries","nestedSeries","xy","generateSeriesXY","xScaleSpec","stackX","yScaleSpec","stackY","xScale","computeScale","yScale","computedSeries","position","x","y","series","generateSeriesAxis","getValue","d","setValue","scaleSpec","serie","parseFloat","String","values","all","sortBy","last","uniq","stackAxis","otherAxis","compare","isDate","stack","stackValue","head","arrayWithHoles","iterableToArrayLimit","nonIterableRest","centerScale","bandwidth","offset","timeDay","timeInterval","end","start","utcDay","timeByType","week","sunday","monday","tuesday","wednesday","thursday","friday","saturday","timeTypes","Object","timeIntervalRegexp","isInteger","isFinite","getScaleTicks","Array","matches","amount","type","timeType","originalStop","stop","Number","interval"],"mappings":"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","sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"@babel/runtime/helpers/esm/arrayWithoutHoles\";\nimport iterableToArray from \"@babel/runtime/helpers/esm/iterableToArray\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableSpread from \"@babel/runtime/helpers/esm/nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","import { timeParse, utcParse } from 'd3-time-format'\n\nexport const timePrecisions = [\n    'millisecond',\n    'second',\n    'minute',\n    'hour',\n    'day',\n    'month',\n    'year',\n] as const\n\nexport type TIME_PRECISION = typeof timePrecisions[number]\n\nexport const precisionCutOffs: ((date: Date) => void)[] = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType: Record<TIME_PRECISION, ((date: Date) => void)[]> = {\n    millisecond: [],\n    second: precisionCutOffs.slice(0, 1),\n    minute: precisionCutOffs.slice(0, 2),\n    hour: precisionCutOffs.slice(0, 3),\n    day: precisionCutOffs.slice(0, 4),\n    month: precisionCutOffs.slice(0, 5),\n    year: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = (precision: TIME_PRECISION) => (date: Date) => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}: {\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    useUTC?: boolean\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n\n    return (value: Date | string | undefined) => {\n        if (value === undefined) {\n            return value\n        }\n\n        if (format === 'native' || value instanceof Date) {\n            return precisionFn(value as Date)\n        }\n\n        const parseTime = useUTC ? utcParse(format) : timeParse(format)\n        return precisionFn(parseTime(value as string) as Date)\n    }\n}\n","import { NumberValue, scaleLinear, ScaleLinear as D3ScaleLinear } from 'd3-scale'\nimport { ScaleLinearSpec, ScaleLinear, ComputedSerieAxis, ScaleAxis } from './types'\n\nexport const createLinearScale = <Output extends NumberValue>(\n    {\n        min = 0,\n        max = 'auto',\n        stacked = false,\n        reverse = false,\n        clamp = false,\n        nice = false,\n    }: ScaleLinearSpec,\n    data: ComputedSerieAxis<Output>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: NumberValue\n    if (min === 'auto') {\n        minValue = stacked === true ? data.minStacked ?? 0 : data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: NumberValue\n    if (max === 'auto') {\n        maxValue = stacked === true ? data.maxStacked ?? 0 : data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLinear<number, Output>()\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .domain(reverse ? [maxValue, minValue] : [minValue, maxValue])\n        .clamp(clamp)\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    return castLinearScale<number, Output>(scale, stacked)\n}\n\nexport const castLinearScale = <Range, Output>(\n    scale: D3ScaleLinear<Range, Output>,\n    stacked = false\n) => {\n    const typedScale = (scale as unknown) as ScaleLinear<number>\n    typedScale.type = 'linear'\n    typedScale.stacked = stacked\n\n    return typedScale\n}\n","import { scalePoint } from 'd3-scale'\nimport { ComputedSerieAxis, ScalePoint, ScalePointSpec, StringValue } from './types'\n\nexport const createPointScale = <Input extends StringValue>(\n    _spec: ScalePointSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number\n) => {\n    const scale = scalePoint<Input>().range([0, size]).domain(data.all)\n\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n","import { scaleBand, ScaleBand as D3ScaleBand } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleBand, ScaleBandSpec, StringValue, ScaleAxis } from './types'\n\nexport const createBandScale = <Input extends StringValue>(\n    { round = true }: ScaleBandSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const scale = scaleBand<Input>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .domain(data.all)\n        .round(round)\n\n    return castBandScale<Input>(scale)\n}\n\nexport const castBandScale = <Input>(scale: D3ScaleBand<Input>) => {\n    const typedScale = scale as ScaleBand<Input>\n    typedScale.type = 'band'\n\n    return typedScale\n}\n","import { NumberValue, scaleTime, scaleUtc } from 'd3-scale'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ComputedSerieAxis, ScaleTime, ScaleTimeSpec } from './types'\n\nexport const createTimeScale = <Input extends Date | NumberValue>(\n    {\n        format = 'native',\n        precision = 'millisecond',\n        min = 'auto',\n        max = 'auto',\n        useUTC = true,\n        nice = false,\n    }: ScaleTimeSpec,\n    data: ComputedSerieAxis<string | Date>,\n    size: number\n) => {\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue: Date | undefined\n    if (min === 'auto') {\n        minValue = normalize(data.min)\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    } else {\n        minValue = min as Date\n    }\n\n    let maxValue: Date | undefined\n    if (max === 'auto') {\n        maxValue = normalize(data.max)\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    } else {\n        maxValue = max as Date\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n\n    scale.range([0, size])\n\n    if (minValue && maxValue) scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = (scale as unknown) as ScaleTime<Input>\n\n    typedScale.type = 'time'\n    typedScale.useUTC = useUTC\n\n    return typedScale\n}\n","import { scaleLog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleLog, ScaleLogSpec } from './types'\n\nexport const createLogScale = (\n    { base = 10, min = 'auto', max = 'auto' }: ScaleLogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const hasZero = data.all.some(v => v === 0)\n    if (hasZero) {\n        throw new Error(`a log scale domain must not include or cross zero`)\n    }\n\n    let sign: number\n    let hasMixedSign = false\n    data.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasMixedSign) {\n        throw new Error(`a log scale domain must be strictly-positive or strictly-negative`)\n    }\n\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLog<number, number>()\n        .domain([minValue, maxValue])\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .base(base)\n        .nice()\n\n    const typedScale = scale as ScaleLog\n    typedScale.type = 'log'\n\n    return scale\n}\n","import { scaleSymlog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleSymlog, ScaleSymlogSpec } from './types'\n\nexport const createSymlogScale = (\n    { constant = 1, min = 'auto', max = 'auto', reverse = false }: ScaleSymlogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleSymlog<number, number>()\n        .constant(constant)\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .nice()\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    const typedScale = scale as ScaleSymlog\n    typedScale.type = 'symlog'\n\n    return typedScale\n}\n","import uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\nimport last from 'lodash/last'\nimport isDate from 'lodash/isDate'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ScaleAxis, ScaleSpec, ScaleValue, SerieAxis, ComputedSerieAxis } from './types'\nimport { createLinearScale } from './linearScale'\nimport { createPointScale } from './pointScale'\nimport { createBandScale } from './bandScale'\nimport { createTimeScale } from './timeScale'\nimport { createLogScale } from './logScale'\nimport { createSymlogScale } from './symlogScale'\n\ntype XY = ReturnType<typeof generateSeriesXY>\n\ntype StackedXY = {\n    [K in keyof XY]: XY[K] & {\n        maxStacked: number\n        minStacked: number\n    }\n}\n\ninterface SerieDatum {\n    x: number | string | Date\n    // only numbers can be stacked\n    xStacked?: number | null\n    y: number | string | Date\n    // only numbers can be stacked\n    yStacked?: number | null\n}\n\ntype Serie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: D[]\n}\n\ntype NestedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n    }[]\n}\n\nexport type ComputedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n        position: {\n            x: number | null\n            y: number | null\n        }\n    }[]\n}\n\ntype Compare = <T>(a: T, b: T) => boolean\n\nexport const getOtherAxis = (axis: ScaleAxis): ScaleAxis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a: string | number, b: string | number) => a === b\nexport const compareDateValues = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport function computeScale<Input extends ScaleValue>(\n    spec: ScaleSpec,\n    data: ComputedSerieAxis<any>,\n    size: number,\n    axis: ScaleAxis\n) {\n    switch (spec.type) {\n        case 'linear':\n            return createLinearScale(spec, data, size, axis)\n        case 'point':\n            return createPointScale<Input>(spec, data, size)\n        case 'band':\n            return createBandScale<Input>(spec, data, size, axis)\n        case 'time':\n            return createTimeScale(spec, data, size)\n        case 'log':\n            return createLogScale(spec, data, size, axis)\n        case 'symlog':\n            return createSymlogScale(spec, data, size, axis)\n        default:\n            throw new Error('invalid scale spec')\n    }\n}\n\n/**\n * Convert serie data to have the original data stored in a nested prop.\n *\n * We do this in order to avoid conflicts between raw & computed properties.\n * <- { data: { x: 1, y: 3 }[] }\n * -> { data: { data: { x: 1, y: 3 } }[] }\n */\nconst nestSerieData = <S = never, D extends SerieDatum = SerieDatum>(\n    serie: Serie<S, D>\n): NestedSerie<S, D> => ({\n    ...serie,\n    data: serie.data.map(d => ({ data: { ...d } })),\n})\n\nconst getDatumAxisPosition = <D extends SerieDatum = SerieDatum>(\n    datum: { data: D },\n    axis: ScaleAxis,\n    scale: any\n): number | null => {\n    if ('stacked' in scale && scale.stacked) {\n        const stackedValue = datum.data[axis === 'x' ? 'xStacked' : 'yStacked']\n        if (stackedValue === null || stackedValue === undefined) {\n            return null\n        }\n\n        return scale(stackedValue)\n    }\n\n    return scale(datum.data[axis]) ?? null\n}\n\n/**\n * Compute x/y d3 scales from an array of data series, and scale specifications.\n *\n * We use generics as it's not uncommon to have extra properties such as an id\n * added to the series, or extra props on data, in such case, you should override\n * the default types.\n */\nexport const computeXYScalesForSeries = <S = never, D extends SerieDatum = SerieDatum>(\n    series: Serie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec,\n    width: number,\n    height: number\n) => {\n    // first nest series to avoid property conflicts\n    const nestedSeries = series.map(serie => nestSerieData<S, D>(serie))\n\n    // then compute data for each axis: all, min, max values\n    const xy = generateSeriesXY<S, D>(nestedSeries, xScaleSpec, yScaleSpec)\n\n    // stack x values depending on xScale\n    if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n        stackX<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // stack y values depending on yScale\n    if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n        stackY<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // computes scales\n    const xScale = computeScale<D['x']>(xScaleSpec, xy.x, width, 'x')\n    const yScale = computeScale<D['y']>(yScaleSpec, xy.y, height, 'y')\n\n    // assign position to each datum in every scale\n    const computedSeries: ComputedSerie<S, D>[] = nestedSeries.map(serie => ({\n        ...serie,\n        data: serie.data.map(datum => ({\n            ...datum,\n            position: {\n                x: getDatumAxisPosition(datum, 'x', xScale),\n                y: getDatumAxisPosition(datum, 'y', yScale),\n            },\n        })),\n    }))\n\n    return {\n        ...xy,\n        series: computedSeries,\n        xScale,\n        yScale,\n    }\n}\n\nexport const generateSeriesXY = <S = never, D extends SerieDatum = SerieDatum>(\n    series: NestedSerie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec\n) => ({\n    x: generateSeriesAxis<'x', D['x']>(series, 'x', xScaleSpec),\n    y: generateSeriesAxis<'y', D['y']>(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = <Axis extends ScaleAxis, Value extends ScaleValue>(\n    series: SerieAxis<Axis, Value>,\n    axis: Axis,\n    scaleSpec: ScaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    }: {\n        getValue?: (d: { data: Record<Axis, Value | null> }) => Value | null\n        setValue?: (d: { data: Record<Axis, Value | null> }, v: Value) => void\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, (parseFloat(String(value)) as unknown) as Value)\n                }\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        // `native` means we already have Date instances,\n        // otherwise we have to convert the values to Date.\n        const parseTime = createDateNormalizer(scaleSpec)\n\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, (parseTime(value as Date) as unknown) as Value)\n                }\n            })\n        })\n    }\n\n    const values: unknown[] = []\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            values.push(getValue(d))\n        })\n    })\n\n    switch (scaleSpec.type) {\n        case 'linear': {\n            const all = sortBy(\n                // filer null values to deal with holes in linechart\n                uniq(values as number[]).filter(v => v !== null),\n                v => v\n            )\n\n            return { all, min: Math.min(...all), max: Math.max(...all) }\n        }\n        case 'time': {\n            const all = uniqBy(values as Date[], v => v.getTime())\n                .slice(0)\n                .sort((a, b) => b.getTime() - a.getTime())\n                .reverse()\n\n            return { all, min: all[0], max: last(all) }\n        }\n        default: {\n            const all = uniq(values)\n\n            return { all, min: all[0], max: last(all) }\n        }\n    }\n}\n\nexport const stackAxis = <S = never, D extends SerieDatum = SerieDatum>(\n    axis: ScaleAxis,\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => {\n    const otherAxis = getOtherAxis(axis)\n    const all: number[] = []\n\n    xy[otherAxis].all.forEach(v => {\n        const compare = (isDate(v) ? compareDateValues : compareValues) as Compare\n        const stack: Array<number | null> = []\n\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n\n            if (datum !== undefined) {\n                // stacked values only support numbers\n                value = datum.data[axis] as number\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n\n                datum.data[axis === 'x' ? 'xStacked' : 'yStacked'] = stackValue\n            }\n\n            stack.push(stackValue)\n\n            if (stackValue !== null) {\n                all.push(stackValue)\n            }\n        })\n    })\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nconst stackX = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('x', xy, series)\n\nconst stackY = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('y', xy, series)\n","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithHoles from \"@babel/runtime/helpers/esm/arrayWithHoles\";\nimport iterableToArrayLimit from \"@babel/runtime/helpers/esm/iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableRest from \"@babel/runtime/helpers/esm/nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","import {\n    CountableTimeInterval,\n    timeMillisecond,\n    utcMillisecond,\n    timeSecond,\n    utcSecond,\n    timeMinute,\n    utcMinute,\n    timeHour,\n    utcHour,\n    timeWeek,\n    utcWeek,\n    timeSunday,\n    utcSunday,\n    timeMonday,\n    utcMonday,\n    timeTuesday,\n    utcTuesday,\n    timeWednesday,\n    utcWednesday,\n    timeThursday,\n    utcThursday,\n    timeFriday,\n    utcFriday,\n    timeSaturday,\n    utcSaturday,\n    timeMonth,\n    utcMonth,\n    timeYear,\n    utcYear,\n    timeInterval,\n} from 'd3-time'\nimport { ScaleValue, TicksSpec, AnyScale, ScaleWithBandwidth } from './types'\n\nexport const centerScale = <Value>(scale: ScaleWithBandwidth) => {\n    const bandwidth = scale.bandwidth()\n\n    if (bandwidth === 0) return scale\n\n    let offset = bandwidth / 2\n    if (scale.round()) {\n        offset = Math.round(offset)\n    }\n\n    return <T extends Value>(d: T) => (scale(d) ?? 0) + offset\n}\n\nconst timeDay = timeInterval(\n    date => date.setHours(0, 0, 0, 0),\n    (date, step) => date.setDate(date.getDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst utcDay = timeInterval(\n    date => date.setUTCHours(0, 0, 0, 0),\n    (date, step) => date.setUTCDate(date.getUTCDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst timeByType: Record<string, [CountableTimeInterval, CountableTimeInterval]> = {\n    millisecond: [timeMillisecond, utcMillisecond],\n    second: [timeSecond, utcSecond],\n    minute: [timeMinute, utcMinute],\n    hour: [timeHour, utcHour],\n    day: [timeDay, utcDay],\n    week: [timeWeek, utcWeek],\n    sunday: [timeSunday, utcSunday],\n    monday: [timeMonday, utcMonday],\n    tuesday: [timeTuesday, utcTuesday],\n    wednesday: [timeWednesday, utcWednesday],\n    thursday: [timeThursday, utcThursday],\n    friday: [timeFriday, utcFriday],\n    saturday: [timeSaturday, utcSaturday],\n    month: [timeMonth, utcMonth],\n    year: [timeYear, utcYear],\n}\n\nconst timeTypes = Object.keys(timeByType)\nconst timeIntervalRegexp = new RegExp(`^every\\\\s*(\\\\d+)?\\\\s*(${timeTypes.join('|')})s?$`, 'i')\n\nconst isInteger = (value: unknown): value is number =>\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n\nexport const getScaleTicks = <Value extends ScaleValue>(\n    scale: AnyScale,\n    spec?: TicksSpec<Value>\n) => {\n    // specific values\n    if (Array.isArray(spec)) {\n        return spec\n    }\n\n    if (typeof spec === 'string' && 'useUTC' in scale) {\n        // time interval\n        const matches = spec.match(timeIntervalRegexp)\n\n        if (matches) {\n            const [, amount, type] = matches\n            // UTC is used as it's more predictable\n            // however local time could be used too\n            // let's see how it fits users' requirements\n            const timeType = timeByType[type][scale.useUTC ? 1 : 0]\n\n            if (type === 'day') {\n                const [start, originalStop] = scale.domain()\n                const stop = new Date(originalStop)\n\n                // Set range to include last day in the domain since `interval.range` function is exclusive stop\n                stop.setDate(stop.getDate() + 1)\n\n                return timeType.every(Number(amount ?? 1))?.range(start, stop) ?? []\n            }\n\n            if (amount === undefined) {\n                return scale.ticks(timeType)\n            }\n\n            const interval = timeType.every(Number(amount))\n\n            if (interval) {\n                return scale.ticks(interval)\n            }\n        }\n\n        throw new Error(`Invalid tickValues: ${spec}`)\n    }\n\n    // continuous scales\n    if ('ticks' in scale) {\n        // default behaviour\n        if (spec === undefined) {\n            return scale.ticks()\n        }\n\n        // specific tick count\n        if (isInteger(spec)) {\n            return scale.ticks(spec)\n        }\n    }\n\n    // non linear scale default\n    return scale.domain()\n}\n"]},"metadata":{},"sourceType":"module"}